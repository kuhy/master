#+TITLE: Source Code Quality impact @@latex:\\@@ on Pull Requests acceptance
#+AUTHOR: OndÅ™ej Kuhejda
* Introduction
** Problem statement
   - Is there some correlation between the source code quality and the pull request acceptance?
   - Which issues/code smells affect the PR acceptance most?
   - Is code quality impact higher in projects that are using some particular programming language?
   - Is there a better code quality in projects which are using linters as part of their CI?
   - Is there a better code quality in projects which are using linters as part of their build process?
   - Does code smells lead to a longer discussion about PR?
* Code quality in pull-based development
  The pull-based development model created novel ways how can developers
  interact between each other. Instead of pushing code changes (patches) into
  one central repository, developers can work in more decentralized and
  distributed way. This is mainly done by using distributed version control
  systems such as Git. Git enables developers to clone repositories and thus to
  work independently on projects. Furthermore, the Git's branching model helps
  developers to keep track of repository changes and helps to handle the
  conflicts between the different changes of the same code base.

  To furthermore ease the complicated process of resolving conflicts between
  different changes (of the same code base) and to provide a more user-friendly
  environment for developers, platforms such as GitHub was created. These
  platforms adds new ways how the developers can interact beyond the basic
  functionality of Git:
  - The forks enables to create the server-side copy of the repository.
  - Pull requests (on some platforms called merge requests) enables to merge code directly on the platform.
  - Users can report issues found in the projects; therefore, platform can also serve as a bug-tracking system.
  - The comments can be added to the pull requests and issues in order to build up social interaction between developers.
  - Users can star projects and follow other users, projects, pull requests or issues.

  In this study, I choose to use GitHub as the main source for data
  mining. GitHub is one of the leading platforms that enables pull-based
  collaboration between developers. GitHub hosts huge amount of publicly
  available repositories and GitHub also provides public REST API that can be
  easily leveraged for data mining.

  The aim of this thesis is to obtain large amount of data about GitHub projects
  and analyze the pull request in regard of their code quality. How the code
  quality can be analyzed and how the GitHub platforms contributes to quality of
  the code itself is discussed in the following chapters.
**** TODO cite: An Exploratory Study of the Pull-based Software Development Model
** TODO Code quality
** TODO GitHub
   - GitHub issues and code quality
   - Ways to merge code
     - An Exploratory Study of the Pull-based Software Development Model
   - PRs and code review
   - PRs CI/CD and code quality
     - Wait for It: Determinants of Pull Request Evaluation Latency on GitHub[[cite:latency]]
       - CI and latency
     - Trautsch et al.[[cite:pmd]] analyzed several open-source projects in regards to
       usage of static analysis tools.  They found out that incorporating a static
       analysis tool in a build process reduces the defect density.
* Pull request acceptance
  Pull request acceptance is a problem that has been studied multiple
  times. Several surveys were performed in order to understand why pull requests
  are being rejected.

  Gousios et al.[[cite:integrator]] surveyed hundreds of integrators to find out
  their reasons behind the PR rejection. Code quality was stated as the main
  reason by most of the integrators; code style was in the second place.
  Factors that integrators examine the most when evaluating the code quality are
  style conformance and test coverage.

  Kononenko et al.[[cite:shopify]] performed a study of an open-source project
  called /Shopify/; they manually analyzed PR's and also surveyed /Shopify/
  developers. They found out that developers associate the quality of PR with
  the quality of its description and with the revertability and complexity of
  the PR.

  The reasons why contributors abandon their PRs were also
  studied[[cite:abandonment]]. The reason number one was the ``Lack of answers from
  integrators.''; moreover, the ``Lack of time'' and the ``Pull request is
  obsolete'' was also often stated as the main reason.

  Even though the different open-source communities solve the problem of pull
  request acceptance in a different manner, three main governance styles can be
  identified --- protective, equitable, lenient. Protective governance style
  values trust in the contributor-maintainer relationship. The equitable
  governance style tries to be unbiased towards the contributors, and the
  lenient style prioritizes the growth and openness of the community[[cite:foss]].
  Each style focuses on different aspects of PR. Tsay et al.[[cite:social]]
  identified the following levels of social and technical factors that influence
  the acceptance of the PR --- /repository level/, /submitter level/, and the
  /pull request level/.
** Repository level
   The /repository level/ is interested in the aspects of the repository itself,
   such as the repository age, number of collaborators, or number of stars on
   the GitHub.

   For instance, the programming language used in the project also influences
   the acceptance of the PRs. Pull requests containing Java, JavaScript, or C++
   code have a smaller chance to be accepted than PRs containing the code
   written in Go or Scala[[cite:factors]].

   Furthermore, older projects and projects with a large team have a
   significantly lower acceptance rate[[cite:social]].

   The popularity of the project also influences the acceptance rate ---
   projects with more stars have more rejected PRs[[cite:social]].
** Submitter level
   The /submitter level/ is concerned about the submitter's status in the
   general community and his status in the project itself. There are several
   parameters that can be considered when evaluating the submitter's status.

   PRs of submitters with higher social connection to the project have a higher
   probability of being accepted[[cite:social]].

   Submitter status in the general community plays an important role in PR
   acceptance. If the submitter is also a project collaborator, the likelihood
   that the PR will be accepted increases by 63.3%[[cite:social]].

   Moreover, users that contributed to a larger number of projects have a higher
   chance that their PR will be accepted[[cite:npm2]].

   The gender of the submitter is another factor that plays a role in PR
   acceptance. A study showed that woman's PR are accepted more often, but only
   when they are not identifiable as a woman[[cite:gender]].

   Personality traits also influence PR acceptance. The /IBM Watson Personality
   Insights/ were used to obtain the personality traits of the PR submitters by
   analyzing the user's comments. These traits were then used to study PR
   acceptance. It has been shown that conscientiousness, neuroticism, and
   extroversion are traits that have positive effects on PR acceptance. The
   chance that PR will be accepted is also higher when the submitter and closer
   have different personalities[[cite:personality]].
** Pull request level
   The /pull request level/ is interested in the data that are connected to the
   PR itself.  For instance, on the /PR level/, one can study if there is
   a correlation between PR acceptance and the number of GitHub comments in
   the PR. Another parameter that can be used is ``Number of Files Changed'' or
   ``Number of Commits''.

   One of the factors that negatively influence the acceptance rate is the
   already mentioned number of commits in the pull request. The high number of
   commits decreases the probability of acceptance. On the other hand, PR's with
   only one commit are exceptions --- they have a smaller chance to be accepted
   than pull requests which contain two commits[[cite:npm2]].

   Another observation is that more discussed PR's has a smaller chance to be
   accepted[[cite:social]].  Another study did not find a large difference between
   accepted and rejected PR's based on the number of comments but found that
   discussions in rejected PR's have a longer duration[[cite:discussion]].

   Proper testing is the crucial part of every project, and therefore it also
   influences the pull request acceptance.  PR's including more tests have a
   higher chance to be accepted, and an increasing number of changed lines
   decreases the likelihood of PR acceptance[[cite:social]].

   Testing plays a significant role in discovering bugs and therefore leads to
   higher code quality. On the other hand, many test cases do not have
   to mean that code has a high quality. The code quality is an essential
   factor on the /pull request level/, therefore, is this study's main interest.
   Works that are also interested in the code quality and the pull
   request acceptance are examined in the following chapter.

   Another factor that is closely tied to code quality is the code style.
   This factor has a small (but not negligible) negative effect on
   acceptance. This means that PRs with larger code style inconsistency
   (with the codebase) have a smaller chance of being accepted[[cite:style]].
** TODO Code quality
   Although most integrators view code quality as the most important factor
   regarding PR acceptance, to the best of my knowledge, only one study was
   performed to discover whether there is a connection between the PR's
   acceptance and its quality.
   - Does code quality affect pull request acceptance?[[cite:quality]]
** TODO Unsorted
   - study ``Influence of Social and Technical Factors''[[cite:social]] was replicated[[cite:personality]]
   - Replication Can Improve Prior Results: A GitHub Study of Pull Request Acceptance[[cite:replication]]
     - contains interesting table with factors that influences acceptance
   - Pull Request Decision Explained: An Empirical Overview[[cite:empirical]]
     - also contains interesting table with factors that influences acceptance
   - An Exploratory Study of the Pull-Based Software Development Model[[cite:explaratory]]
   - Which Pull Requests Get Accepted and Why? A study of popular NPM Packages[[cite:npm]]
   - Rejection Factors of Pull Requests Filed by Core Team Developers in Software Projects with High Acceptance Rates[[cite:developers]]
   - Pull Request Prioritization Algorithm based on Acceptance and Response Probability[[cite:prioritization]]
** TODO Create table that compares already performed studies with my thesis
* Data mining
  #+BEGIN_EXPORT latex
  \begin{figure}[htb]\centering
  \begin{tikzpicture}
  \node (n1) [align=center] {Project\\name};
  \node (n2) [box, above=of n1, align=center] {\texttt{gh\_info.py}};
  \node (n3) [cloud, draw, above=of n2, align=center] {GHTorrent\\database};
  \node (n4) [right=of n2, align=center] {Pull requests\\information};
  \node (n5) [box, right=of n4] {\texttt{git-contrast}};
  \node (n6) [cloud, draw, above=of n5] {Linters};
  \node (n7) [below=of n5, align=center] {Pull requests\\code quality};
  \node (n8) [below=of n4, align=center] {Project\\information};

  \node [container, fit=(n1)(n2)(n3)(n4)(n5)(n6)(n7)(n8)] {};
  \node [below left, inner sep=3mm] at (current bounding box.north east) {\texttt{pr\_quality.py}};

  \draw[->] (n1) to (n2);
  \draw[<->] (n2) to (n3);
  \draw[->] (n2) to (n4);
  \draw[->] (n4) to (n5);
  \draw[<->] (n5) to (n6);
  \draw[->] (n5) to (n7);
  \draw[->] (n2) to (n8);
  \end{tikzpicture}
  \caption{The \texttt{pr\_quality.py} workflow}\label{workflow}
  \end{figure}
  #+END_EXPORT
  Information about the pull requests are retrieved using the =pr_quality.py=
  script. This scripts takes names of the projects that will be analyzed as the
  input and it outputs the JSON files containing the requested data. This script
  uses internally two other scripts --- =gh_info.py= and =git-contrast=.

  =gh_info.py= is responsible for querying the GHTorrent database in order to
  obtain data about the projects. The GHTorrent database is an offline mirror of
  data offered through the Github REST API. =gh_info.py= returns a JSON file
  with the information about the project such as number of stars, number of
  contributors or information about pull requests and their commits.

  However, the Github REST API lacks the information about the code quality of
  the pull requests. This is where the =git-contrast= comes into the play.
  =git-contrast= is the command-line application which analyzes the code quality
  of the given pull request using the external linters. This application is
  further discussed in the following sections.
** GHTorrent database
   As stated before, the script called =gh_info.py= uses the GHTorrent database
   in order to retrieve GitHub data. GitHub REST API can be leveraged to obtain
   many interesting factors which can possibly influence the acceptance of pull
   requests. All the data that are obtained using the =gh_info.py= are listed
   in the following table:
   #+CAPTION: Data retrieved from the GHTorrent
   #+ATTR_LaTeX: :align |llc|
   |--------------------+---------------------------+-----------|
   | Level              | Variable                  | Factor    |
   |--------------------+---------------------------+-----------|
   |--------------------+---------------------------+-----------|
   | Repository level   | Project name              | \ding{55} |
   |                    | Programming language      | \ding{51} |
   |                    | Time of creation          | \ding{51} |
   |                    | Number of forks           | \ding{51} |
   |                    | Number of commits         | \ding{51} |
   |                    | Number of project members | \ding{51} |
   |                    | Number of watchers        | \ding{51} |
   |--------------------+---------------------------+-----------|
   | Submitter level    | Username                  | \ding{55} |
   |                    | Number of followers       | \ding{51} |
   |                    | Status in the project     | \ding{51} |
   |--------------------+---------------------------+-----------|
   | Pull request level | Pull request ID           | \ding{55} |
   |                    | Is PR accepted?           | \ding{51} |
   |                    | Time opened               | \ding{51} |
   |                    | Head repository           | \ding{55} |
   |                    | Head commit               | \ding{55} |
   |                    | Base commit               | \ding{55} |
   |                    | Number of commits         | \ding{51} |
   |                    | Number of comments        | \ding{51} |
   |--------------------+---------------------------+-----------|

   Variables marked with ticks (\ding{51}) are later used as an statistical data
   for analysis of pull request acceptance or as factors that can influence code
   quality. Other variables (\ding{55}) are not meant to be used as an part of
   an data analysis itself, but are kept here for better orientation; and some
   of them are later used by the =git-contrast= tool (in order to pull the
   commits which will be subsequently analyzed by linters).
** =git-contrast=
   =git-contrast= is the command line application that I implemented in order to
   be able to analyze the code quality of the given pull request. =git-contrast=
   expects two commit hashes on the input and returns the information about the
   change in code quality between these commits on the output. This is done by
   running the linter on the files in the state of the first commit and then in
   the state of the second commit. The number of found code quality issues is
   then written to the standard output.

   To measure the change of the quality in the pull request, we simple run the
   =git-contrast= on the ``head commit'' and the ``base commit'' of the given
   pull request. =git-contrast= supports several linters; which linter will be
   used is determined by the file extension of the tested file. Linters that are
   supported by =git-contrast= are listed in the following table:
   #+CAPTION: Linters supported by the =git-contrast=
   #+ATTR_LaTeX: :align |lll|
   |------------+-----------------------+-----------------------|
   | Linter     | Programming languages | File extensions       |
   |------------+-----------------------+-----------------------|
   |------------+-----------------------+-----------------------|
   | *Cppcheck* | C/C++                 | =.c=, =.cpp= and =.h= |
   | *HLint*    | Haskell               | =.hs=                 |
   | *ktlint*   | Kotlin                | =.kt= and =.kts=      |
   | *PMD*      | Java                  | =.java=               |
   | *Pylint*   | Python                | =.py=                 |
   |------------+-----------------------+-----------------------|
** TODO Projects selection
   - https://dl.acm.org/doi/abs/10.1145/2597073.2597122
   - https://dl.acm.org/doi/abs/10.1145/3379597.3387489
   - https://zenodo.org/record/3858046
   - https://github.com/XLipcak/rev-rec
   - https://ghtorrent.org/
     - https://github.com/gousiosg/pullreqs
     - How can I cite this work? (on the web)
   - Kalliamvakou et al. noted that data about PR's mined from GitHub are not always reliable,
     because PR can be also merged using several different approaches.
     - https://dl.acm.org/doi/10.1145/2597073.2597074
     - [[cite:explaratory]]
* Data analysis
* Evaluation
** Threads to validity
* Conclusion
** Future work
* Appendix
* Setup :noexport:
#+LATEX_CLASS: fithesis4
#+LATEX_CLASS_OPTIONS: [digital,oneside,oldtable,nolof,nolot,nocover]
#+LATEX_HEADER: \usepackage{style}
#+BIND: org-latex-title-command ""
#+BIND: org-latex-toc-command ""
#+BIND: org-latex-with-hyperref nil
#+BIND: org-latex-listings minted
#+BIND: org-src-preserve-indentation nil
#+BIND: org-edit-src-content-indentation 0
# Local Variables:
# mode: org
# org-export-allow-bind-keywords: t
# org-latex-classes: '("fithesis4" "\\documentclass{fithesis4}
#                            [NO-DEFAULT-PACKAGES]
#                            [NO-PACKAGES]"
#                        ("\\chapter{%s}" . "\\chapter*{%s}")
#                        ("\\section{%s}" . "\\section*{%s}")
#                        ("\\subsection{%s}" . "\\subsection*{%s}")
#                        ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
#                        ("\\paragraph{%s}" . "\\paragraph*{%s}")
#                        ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
# org-latex-pdf-process: ("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
#                         "biber %b"
#                         "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
#                         "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")
# display-line-numbers-width: 4
# eval: (org-add-link-type "cite"
#         (defun follow-cite (name))
#         (defun export-cite (path desc format)
#           (if (eq format 'latex)
#           (if (or (not desc) (equal 0 (search "cite:" desc)))
#             (format "~\\cite{%s}" path)
#             (format "~\\cite[%s]{%s}" desc path)))))
# End:
